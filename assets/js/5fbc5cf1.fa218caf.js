(self.webpackChunk_parsed_path_docs=self.webpackChunk_parsed_path_docs||[]).push([[207],{44327:function(t,e,n){"use strict";n.r(e),n.d(e,{frontMatter:function(){return o},metadata:function(){return i},toc:function(){return d},default:function(){return c}});var a=n(7560),r=n(98283),p=(n(2784),n(30876)),s=["components"],o={sidebar_position:3},i={unversionedId:"api",id:"api",isDocsHomePage:!1,title:"API References",description:"Parsed",source:"@site/docs/api.md",sourceDirName:".",slug:"/api",permalink:"/docs/api",editUrl:"https://github.com/tseijp/parsed-path/edit/master/examples/docs/docs/api.md",version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/docs/get"}},d=[{value:"Parsed",id:"parsed",children:[]},{value:"Adapting based on props",id:"adapting-based-on-props",children:[]},{value:"Extending parses",id:"extending-parses",children:[]},{value:"Parsing any pathname",id:"parsing-any-pathname",children:[]},{value:"Attaching additional props",id:"attaching-additional-props",children:[]}],l={toc:d};function c(t){var e=t.components,n=(0,r.Z)(t,s);return(0,p.kt)("wrapper",(0,a.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,p.kt)("h3",{id:"parsed"},"Parsed"),(0,p.kt)("p",null,"This is the default export. We use to create the parsed.tag helper method.\nReturn a function that accepts a tagged template literal and turns it into a pathname."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-js"},"const Api = parsed.https`tsei.jp``api``v${props => props.version}`;\n\nrender(\n  <>\n    <Api version={1}/>\n    <Api version={2}/>\n  </>\n);\n")),(0,p.kt)("h3",{id:"adapting-based-on-props"},"Adapting based on props"),(0,p.kt)("p",null,"You can pass a function to a parsed path's template literal to adapt it based on its props.\nWhen setting the next prop to true, we are switching its version number."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-js"},'const Api = parsed`api``v${props => props.next? 2: 1}`;\nconst Get = Api`${props =>\n  props.version === 1\n    ? "get/is/undefined"\n    : "get"\n}`\n\nrender(\n  <>\n    <Api/>\n    <Get/>\n    <Api next/>\n    <Get next/>\n  </>\n);\n')),(0,p.kt)("h3",{id:"extending-parses"},"Extending parses"),(0,p.kt)("p",null,"To easily make a new pathname that inherits from another paths.\nHere we use the api url from the last section and create a special one."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-js"},"const Api = parsed.http`tsei.jp``api`;\n\nconst Dev = Api`\n  root: localhost;\n  port: 3000;\n`;\n\nrender(\n  <>\n    <Api/>\n    <Dev/>\n  </>\n);\n")),(0,p.kt)("h3",{id:"parsing-any-pathname"},"Parsing any pathname"),(0,p.kt)("p",null,"The parsed method works perfectly on all of your own or any third-party pathname."),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-js"},'const Url = new URL("https://localhost:3000/");\nconst Api = parsed(Url)`\n  port: 3001;\n  root: http;\n`;\n\nrender(\n  <>\n    <Api/>\n    <Api port="8000"/>\n  </>\n);\n')),(0,p.kt)("h3",{id:"attaching-additional-props"},"Attaching additional props"),(0,p.kt)("p",null,"To avoid unnecessary wrappers that just pass on some props to the path,\nyou can use the .withAttrs constructor.\nIt allows you to attach additional props to a path."),(0,p.kt)("p",null,"Furthermore you can also attach more dynamic props to a component.\nThe .withAttrs object also takes functions,\nthat receive the props that the path receives.\nThe return value will be merged into the resulting props as well."),(0,p.kt)("p",null,"Here we render an root path and attach some dynamic and static attributes to it:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-js"},'const Root = parsed`\n  port: ${props => props.port}\n  root: ${props => props.root}\n`;\n\nconst Api = Root`api``v1`.withAttrs(props => ({\n  dev: false,\n  port: props.dev? 3000: undefined,\n  root: props.dev? "localhost": "tsei.jp"\n}));\n')),(0,p.kt)("p",null,"This allows each wrapper to override nested uses of .withAttrs.\nRoot's .attrs are applied first, and then Api's .attrs:"),(0,p.kt)("pre",null,(0,p.kt)("code",{parentName:"pre",className:"language-js"},"const Dev = Api.withAttrs(props => ({dev: false});\nconst Pro = Api.withAttrs(props => ({dev: true}));\n\nrender(\n  <>\n    <Api/>\n    <Dev/>\n    <Pro/>\n  </>\n);\n")))}c.isMDXComponent=!0}}]);